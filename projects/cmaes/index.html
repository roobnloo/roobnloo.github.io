<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> CMA-ES | Robin Liu </title> <meta name="author" content="Robin Liu"> <meta name="description" content="Comparing the performance of two blackbox or " derivative-free optimization methods.> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.png?405da0127cc4591237d4afbd0e63c899"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://alshedivat.github.io/projects/cmaes/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Robin</span> Liu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">CMA-ES</h1> <p class="post-description">Comparing the performance of two blackbox or "derivative-free" optimization methods.</p> </header> <article> <p>We discuss the Covariance Matrix Adaptation Evolution Strategy (CMA-ES), a blackbox optimization algorithm for arbitrary functions that are not necessarily smooth or convex. We compare the performance of CMA-ES against a more naive approach on a couple of test functions, demonstrating that the clever updating strategies in CMA-ES result in better performance. Finally, we look at an application of CMA-ES in real research related to image-guided navigation during surgery. A comprehensive guide to CMA-ES is provided in [<a href="#ref1">1</a>]. All code, including the implementation and code to generate the plots in this report, are on <a href="https://github.com/roobnloo/blackboxopt" rel="external nofollow noopener" target="_blank">Github</a>.</p> <p>\(\renewcommand{\vec}[1]{\boldsymbol{\mathbf{#1}}} \newcommand{\R}{\mathbb{R}} \newcommand{\EE}{\mathbb{E}}\)</p> <h2 id="1-introduction">1 Introduction</h2> <p>When a function is smooth and convex, we can find the global minimizer using first-order methods such as gradient descent. Moreover, the theoretical properties of the update steps are well understood, e.g. we can give an upper bound on the step size that guarantees convergence, or use backtracking to find a suitable reduction of the objective function at each step.</p> <p>Minimization problems are much harder when the objective function is non-smooth. If a function is not differentiable, we certainly cannot perform gradient descent. If a function is not convex, we cannot conclude that a local minimum we have found is a global minimum. Despite these challenges, there exist methods that aim to minimize non-smooth and non-convex functions. Such methods are called <em>blackbox</em> or <em>derivative-free</em> methods, indicating that evaluating the derivative is not necessary.</p> <p>Our setting is the simple unconstrained problem given by</p> \[\operatorname*{minimize}_{\vec x \in \R^n} f(x),\quad f\colon \mathbb{R}^n \to\mathbb{R} \text{ is an arbitrary function.}\] <p>We require that \(f\) can be evaluated at every point in \(\mathbb{R}^n\). We compare two methods for this problem: the <em>cross-entropy method</em> and the <em>Covariance Matrix Adaptation Evolution Strategy</em> (CMA-ES). Both of these methods place a probability distribution, called the <em>proposal distribution</em>, over the domain of \(f\) and at each iteration, sample points from the domain and update the distribution based on a subset of <em>elite</em> design points. The mean of the ultimate distribution at convergence yields an estimate for the minimizer. In this project we use the multivariate normal proposal distribution for both methods.</p> <p>We first give an outline of the cross-entropy method, focusing on how it performs parameter updates using maximum likelihood estimates. Then we explore the CMA-ES parameter update steps. We compare the performance of the two methods on the 2-dimensional flower function and the 20-dimensional Michalewicz function, given in <a href="#testfns">Appendix A.2</a>.</p> <h2 id="2-a-naive-approach">2 A Naive Approach</h2> <h3 id="21-mles-and-cross-entropy">2.1 MLEs and Cross-entropy</h3> <p>We wish to minimize \(f\), but aside from its value at points in the domain, we know nothing of the structure of \(f\). Our strategy is to sample points in the domain via a \(N(\vec\mu, \vec \Sigma)\) distribution and update \(\vec \mu\) and \(\vec \Sigma\) based on a subset of “elite” sample points, i.e. those with low \(f\) value. We call this approach “naive” because \(\vec \mu\) and \(\vec \Sigma\) are updated in the most obvious way: they become the MLEs of the elite sample.</p> <p>This is Algorithm 1. Convergence can be taken to mean that the mean vector of the distribution has not changed beyond a provided tolerance. In the final two steps we update \(\vec \mu'\) to be the sample average of the elite sample and \(\vec \Sigma'\) to be the sample covariance of the elite sample, with respect to \(\vec \mu'\).</p> <p>The algorithm is intuitively appealing. In fact, it can be shown that this algorithm is an instance of the <em>cross-entropy</em> method for multivariate normals; in this case, minimizing the cross-entropy of the two distributions amounts to computing the MLE.</p> <hr> <p><strong>Algorithm 1:</strong> Cross-entropy with Multivariate Gaussian (CEMVN) <br> <strong>Require:</strong> \(f\colon \R^n \to \R\), initial parameters \((\vec \mu^{(0)}, \vec\Sigma^{(0)})\), \(m\) size of sample, \(m_{\text{elite}}\) size of elite subsample. <br> <strong>Ensure:</strong> \(\vec \mu^{(T)}\) is the mean of the final distribution and the proposed minimizer.</p> <p>For \(t = 0, 1, \dotsc\) until convergence:</p> <ul> <li>Sample points \(\vec x_1, \dotsc, \vec x_m\) from distribution \(N(\vec\mu^{(t)}, \vec \Sigma^{(t)})\).</li> <li>Let \(\vec x_{(1)}, \ldots, \vec x_{(m)}\) be the sample ordered so that \(f(\vec x_{(j)}) \leq f(\vec x_{(j+1)})\).</li> <li>Update \(\vec \mu^{(t+1)} \leftarrow \text{mean}(\vec x_{(1)}, \ldots, \vec x_{(m_{\text{elite}})})\)</li> <li>Update \(\vec \Sigma^{(t+1)} \leftarrow \frac{1}{m_{\text{elite}}}\sum_{k=1}^{m_{\text{elite}}} (\vec x^{(k)} - \vec\mu^{(t+1)})(\vec x^{(k)} - \vec\mu^{(t+1)})^\intercal\)</li> </ul> <hr> <h3 id="22-issues-with-the-naive-approach">2.2 Issues with the naive approach<a name="cemvnflower"></a> </h3> <p>We motivate the CMA-ES approach in the next section by outlining three problems with the naive method.</p> <ul> <li>In updating the mean, the elite points are equally weighted. The sample average of the elite points are calculated without regard to their values of \(f\).</li> <li>In updating the covariance matrix, the <em>update path</em> is not remembered.</li> <li>The lack of scaling parameter means the covariance matrix may prematurely shrink.</li> </ul> <p>These problems are highlighted in the Figure 1. We ran CEMVN on the <a href="#testfns">flower function</a>, initialized with a mean of \((2,2)\) and identity covariance. Blue and green indicates smaller and larger values of the flower function, respectively. The function is minimized near the center of the “flower”, which is at the origin. Each plot shows the ten elite points sampled from the bivariate normal whose level curves are also plotted in white. While the mean starts to shift toward the origin, the covariance degenerates too quickly for enough points to be sampled near the optimum, resulting in premature convergence.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/cemvn_flower-480.webp 480w,/assets/img/cmaes/cemvn_flower-800.webp 800w,/assets/img/cmaes/cemvn_flower-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/cemvn_flower.png" class="img-fluid rounded" width="100%" height="auto" title="CEMVN flower function" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Figure 1: Performance of the cross-entropy method on the flower function using 10 elite samples out of 20 initialized at (2,2). We see premature convergence to a suboptimal point. </div> <h2 id="3-the-covariance-matrix-adaptation-evolutionary-strategy">3 The Covariance Matrix Adaptation Evolutionary Strategy<a name="cma"></a> </h2> <p>The CMA-ES method remedies these issues. At each step, \(\vec x \sim N(\vec \mu, \sigma^2 \vec\Sigma)\) is sampled. The following summarizes the key differences from the naive approach.</p> <ul> <li>The mean vector is updated by a weighted average of the elite points.</li> <li>The covariance matrix is updated by considering the elite sample points along with <em>correlations between previous generations</em>. This is accomplished via <em>cumulation</em>.</li> <li>The step size is controlled via the parameter \(\sigma\), which is also updated in a data-adaptive way via cumulation. This ameliorates premature convergence.</li> </ul> <p>The last two points cause the covariance matrix to <em>adapt</em> to the samples, unlike the cross-entropy method in which previous information is discarded. Like the cross-entropy method, we use \(m\) samples at each step and select an elite sample of size \(m_{\text{elite}}\). The function \(f\colon \R^n \to \R\) is to be minimized. We will discuss how the method updates the mean, covariance matrix, and overall step size parameters. These update steps form the basis of full algorithm, given in Appendix <a href="#cmaesalg">A.3</a>.</p> <h3 id="31-updating-the-mean">3.1 Updating the mean</h3> <p>Unlike the naive method, the mean is updated by weighting each elite point according to its \(f\) value. Let \(\vec x_{(1)}, \ldots, \vec x_{(m_{\text{elite}})}\) be the elite sample such that \(f(\vec x_{(i)}) \leq f(\vec x_{(i+1)})\). The mean is updated as \begin{equation} \label{eq:meanstep} \vec\mu’ = \sum_{i=1}^{m_{\text{elite}}} w_i \vec x_{(i)}, \quad w_i = \log \frac{m+1}{2} - \log i\; \text{for $i = 1,\ldots, m_{\text{elite}}$}. \end{equation} These values of weights \(\{w_i\}\) are recommended by the authors of the original work; they are decreasing, hence heavier for the \(x_{(i)}\) where \(i\) is small. A comparison of the weighted versus the unweighted (naive) mean updated is shown in Figure 2. Due to the weights, the new mean is more aggressively pulled toward the origin.</p> <p>The weights \(w_i\) are characterized by its <em>variance effective selection mass</em>, given by</p> \[\mu_{\text{eff}} = \frac{1}{\sum_{i=1}^{m_{\text{elite}}} w_i^2}.\] <p>This value will show up in the sequel as a part of the recommended settings for various parameters of the algorithm.</p> <div class="row justify-content-sm-center"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/mean_update_comparison-480.webp 480w,/assets/img/cmaes/mean_update_comparison-800.webp 800w,/assets/img/cmaes/mean_update_comparison-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/mean_update_comparison.png" class="img-fluid rounded" width="100%" height="auto" title="mean update compare" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 2: Updating the mean via cross-entropy (blue) vs CMA-ES (red). The CMA-ES mean update is closer to points with low objective value. </div> <h3 id="32-updating-the-covariance-matrix">3.2 Updating the covariance matrix</h3> <p>Unlike the naive method in which covariance information from previous generations is discarded, CMA-ES leverages information from the entire population as well as correlations between successive generations. The final update in (\ref{eq:covupdate}) accomplishes this with three terms: the previous covariance matrix, a rank-one update, and a rank-\(\mu\) update. We describe these in turn.</p> <h4 id="321-the-rank-mu-update">3.2.1 The Rank-\(\mu\) update</h4> <p>Consider again the covariance updating step in Algorithm 1:</p> \[\vec \Sigma^{(t+1)} \gets\frac{1}{m_{\text{elite}}}\sum_{k=1}^{m_{\text{elite}}} (\vec x^{(k)} - \vec\mu^{(t+1)})(\vec x^{(k)} - \vec\mu^{(t+1)})^\intercal.\] <p>Since \(\vec\mu^{(t+1)}\) is the sample mean, this expression is the variance <em>within the sampled points</em> \(\vec x^{(k)}\). Instead, the expression</p> \[\frac{1}{m_{\text{elite}}}\sum_{k=1}^{m_{\text{elite}}} (\vec x^{(k)} - \vec\mu^{(t)})(\vec x^{(k)} - \vec\mu^{(t)})^\intercal\] <p>where \(\vec\mu^{(t+1)}\) is replaced by \(\vec\mu^{(t)}\), the mean of the original distribution, describes the variance of the <em>sampled steps</em>. As in the mean update, we give a heavier weight to more “successful” steps using the weights \(w_i\) by defining</p> \[\vec\Sigma_{\mu}^{(t)} = \sum_{k=1}^{m_{\text{elite}}} w_i (\vec x^{(k)} - \vec\mu^{(t)})(\vec x^{(k)} - \vec\mu^{(t)})^\intercal.\] <p>Sampling from the covariance matrix \(\vec\Sigma_{\mu}^{(t)}\) tends to reproduce the steps resulting in large decrease of $f$.</p> <p>To finish up the rank-\(\mu\) update, we scale \(\vec\Sigma_{\mu}^{(t)}\) by the step size parameter \(\sigma^{(t)}\) (see Sec <a href="#secstep">3.3</a>) so that these matrices are comparable across different generations, and then we ``smooth’’ the result across different generations. The final covariance matrix \(\vec\Sigma^{(t)}\) is updated as follows:</p> \[\vec\Sigma^{(t+1)} = \left(1 - c_\mu \sum_{i=1}^{m_{\text{elite}}} w_i\right) \vec\Sigma^{(t)} + c_\mu \frac{1}{\sigma^{(t)^2}} \vec\Sigma_\mu^{(t)}.\] <p>The constant \(0\leq c_\mu \leq 1\) is a learning rate which controls how much information from previous generations is kept. Several of these tuning parameters appear in the sequel. They are \(c_\mu, c_c, c_1, c_\sigma\), and \(d_\sigma\). Their recommended values are given in Appendix <a href="#tuning">A.1</a>.</p> <p>This update is called “rank-\(\mu\)” because it can be shown that the outer product in \(\vec\Sigma_\mu^{(t)}\) has rank \(\min(\mu, n)\).</p> <h4 id="322-the-rank-one-update">3.2.2 The Rank-one update</h4> <p>While the rank-\(\mu\) update estimates the covariance matrix from <em>all</em> the steps in a single generation, we would also like to consider the evolution of steps throughout the previous generations. To this end, define the <em>evolution path</em> as the sequence of steps (the mean updates) taken by the algorithm normalized by the factor \(\sigma^{(t)}\) at each step. For example, the evolution path of the first three steps is</p> \[\frac{\vec\mu^{(3)} - \vec\mu^{(2)}}{\sigma^{(2)}} +\frac{\vec\mu^{(2)} - \vec\mu^{(1)}}{\sigma^{(1)}} +\frac{\vec\mu^{(1)} - \vec\mu^{(0)}}{\sigma^{(0)}}.\] <p>The evolution path is actually constructed as a <em>cumulation</em> using a smoothing parameter \(c_c\) and is given by \begin{equation} \label{eq:cum} \vec p_c^{(t+1)} = (1-c_c)\vec p_c^{(t)} + \sqrt{c_c (2-c_c)\mu_{\text{eff}}} \frac{\vec\mu^{(t+1)} - \vec\mu^{(t)}}{\sigma^{(t)}}, \end{equation}</p> <p>Finally, a parameter \(c_1\) controls the learning rate for this update and the final rank-one update is</p> \[\vec\Sigma^{(t+1)} = (1-c_1)\vec\Sigma^{(t)} + c_1 \vec p_c^{(t+1)}\vec p_c^{(t+1)^\intercal}.\] <p>In this way, information about the successive steps between generations is used in updating the covariance matrix.</p> <h4 id="323-putting-it-all-together">3.2.3 Putting it all together</h4> <p>Putting together both updates, we get the final covariance matrix update</p> <p>\begin{equation} \label{eq:covupdate} \vec \Sigma^{(t+1)} =\left(1-c_1-c_\mu \sum_{i=1}^{m_{\text{elite}}} w_i\right)\vec \Sigma^{(t)} + c_1 \vec p_c^{(t+1)} \vec p_c^{(t+1)^\intercal} + c_\mu \frac{1}{\sigma^{(t)^2}} \vec\Sigma_{\mu}^{(t)}. \end{equation}</p> <p>The update combines all the steps in a single generation with the overall step between all generations. The term \(-c_1 - c_\mu \sum_{i=1}^{m_{\text{elite}}} w_i\) is typically close to or equal to zero.</p> <h3 id="33-updating-the-step-size">3.3 Updating the step size<a name="secstep"></a> </h3> <p>Although the covariance matrix update allows the shape of the multivariate normal distribution to evolve, it is necessary for performance to control the overall scale of the distribution. This is done by the parameter \(\sigma^{(t)}\) at each step.</p> <p>To update \(\sigma^{(t)}\), we keep track of the evolution path using cumulation as in \((\ref{eq:cum})\), except we normalize each step by pre-multiplying by \(\vec\Sigma^{(t)^{-1/2}}\), which has the effect of normalizing the step vector. Starting with \(\vec p_\sigma^{(0)}\), the path is updated by</p> \[\vec p_\sigma^{(t+1)} = (1-c_\sigma)\vec p_\sigma^{(t)} + \sqrt{c_\sigma(2-c_\sigma)\mu_{\text{eff}}}\; \vec \Sigma^{(t)^{-1/2}}\; \frac{\vec \mu^{(t+1)} - \vec \mu^{(t)}}{\sigma^{(t)}}.\] <p>where \(c_\sigma\) controls the learning rate.</p> <p>The key idea of the step size update is to increase the step size if the length of normalized steps exceed the expected length of a \(N(\vec 0, \vec I)\) vector, and decrease the step size if the length is less than what is expected from a \(N(\vec 0, \vec I)\) vector. This is depicted in Figure 3, which is copied from [<a href="#ref1">1</a>]. Let \(\vec Z \sim N(0, \vec I)\) be a standard normal random vector. When the individual step sizes in the evolution path are uncorrelated, the length of the normalized evolution path should approximate \(\EE \lVert{\vec Z}\rVert_2 \approx \sqrt{n} + O(1/n)\). If the individual step sizes in the evolution path are positively correlated, the overall evolution path length exceeds \(\EE \lVert{\vec Z}\rVert_2\) and the step size should be increased to take advantage of the correlation. Finally, if the individual step sizes are negatively correlated, the length of the evolution path is smaller than expected random length, and the step size should be decreased to explore the local area. All of this is accomplished by looking at the ratio \(\lVert{\vec p_\sigma^{(t+1)}}\rVert_2 / \EE \lVert{\vec Z}\rVert_2\).</p> <p>The step size is updated by \begin{equation} \label{eq:stepupdate} \sigma^{(t+1)} = \sigma^{(t)} \exp\left(\frac{c_\sigma}{d_\sigma} \left(\frac{\lVert{\vec p_\sigma^{(t+1)}}\rVert_2 }{ \EE \lVert{\vec Z}\rVert_2} - 1\right)\right). \end{equation} where \(d_\sigma\) is a step size adaptation parameter. In this way, the step size adapts to the evolution path, stretching and shrinking the overall scale depending on the length of \(\vec p_\sigma^{(t+1)}\) relative to the expected length of \(\vec Z\).</p> <div class="row justify-content-sm-center"> <div class="col-md-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/evolpath-480.webp 480w,/assets/img/cmaes/evolpath-800.webp 800w,/assets/img/cmaes/evolpath-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/evolpath.png" class="img-fluid rounded" width="100%" height="auto" title="evolution path" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 3: Different scenarios in which the step size is updated. <i>Left</i>: The evolution path is short because the individual steps are anti-correlated. In this case, the step size is shrunk so the local area can be explored. <i>Right</i>: The individual steps are correlated, so the overall path is large. A single large step could cover this distance, so the step size should be increased. <i>Middle</i>: The individual steps are uncorrelated. The step size should not change. </div> <h3 id="34-performance-on-the-flower-function">3.4 Performance on the flower function</h3> <p>Figure 4 shows the result of running CMA-ES on the flower function with the same initial configuration as in Section <a href="#cemvnflower">2.2</a>. We see the adaptation in action: the variances are scaled larger at the start and prevent premature convergence. Compare this behavior to that of Figure 1.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/cma_flower-480.webp 480w,/assets/img/cmaes/cma_flower-800.webp 800w,/assets/img/cmaes/cma_flower-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/cma_flower.png" class="img-fluid rounded" width="100%" height="auto" title="CMA-ES flower function" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Figure 4: Performance of the CMA-ES on the flower function using 10 elite samples out of 20 total sample points with an initial guess of (2,2).</div> <h3 id="35-performance-on-the-michalewicz-function">3.5 Performance on the Michalewicz function</h3> <p>In this section, we examine the performance of CMA-ES against that of the cross-entropy method on a higher-dimensional function. We use the Michalewicz function given in Appendix <a href="#testfns">A.2</a> with dimension \(d= 20\), where it is known that the function has \(20!\) local minima and that that the minimum is approximately \(-19.637\) [<a href="#ref2">2</a>]. Due to the higher dimensionality, we require more samples at each stage for both methods. We ran our implementations of CMA-ES and CEMVN (cross-entropy with multivariate normal) using sample sizes of 100, 600, and 1100 initialized at the point \((1, \dotsc, 1) \in \R^{20}\).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/michalewicz_compare-480.webp 480w,/assets/img/cmaes/michalewicz_compare-800.webp 800w,/assets/img/cmaes/michalewicz_compare-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/michalewicz_compare.png" class="img-fluid rounded" width="100%" height="auto" title="Michalewicz" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Figure 5: Perfomance of CMA-ES and CEMVN (cross-entropy multivariate normal) on the Michalewicz function with dimension 20. CEMVN demonstrates premature convergence for small sample sizes, while CMA-ES avoids local minima early on. </div> <h2 id="4-application-to-spinal-imaging">4 Application to spinal imaging</h2> <p>We turn to [<a href="#ref3">3</a>], which compares CMA-ES to other competing methods on the problem of registering images in the course of spinal surgery. Image-guided navigation is a surgical technique whereby a navigation system maps in real time the location of a surgeon’s instruments on a subject to a computerized image of the subject, such as a preoperative CT scan. <a href="https://youtu.be/_BFTK6LWH5g" rel="external nofollow noopener" target="_blank">Here is a short video explanation of how it works.</a> During surgery, a calibration step is necessary so that the position of the instrument on the patient matches the graphic position of the instrument on the image. This important step is called <em>registration</em>. If a CT scan were improperly registered, the surgeon would see a digital representation of his instrument in the different location compared to where it actually is on the patient: this can be disastrous.</p> <p>In the course of spinal surgery, additional imaging may be required for planning and the new images must be registered. One way to do this is to perform additional CT scans during surgery. Images from a CT scan have high resolution and can be easily registered with the preoperative image. However, this approach is invasive and exposes the subject to unnecessary radiation. An alternative method is to use ultrasounds, which are non-invasive; yet ultrasounds have a low signal-to-noise ratio so that registration is much more challenging.</p> <p>The researchers in [<a href="#ref3">3</a>] consider registering noisy ultrasound images in the course of an operation. Surface points of the spine are extracted from a preoperative CT scan. The problem is to transform an intraoperative ultrasound image so that it is aligned with the surface points. This gives rise to the following optimization problem:</p> \[\operatorname*{maximize}_{\alpha, \beta, \gamma, \Delta_x, \Delta_y, \Delta_z} \sum_{i=1}^N u\left(R_{\alpha\beta\gamma}\cdot p_i + (\Delta_x, \Delta_y, \Delta_z)^\intercal\right)\] <p>where \(R_{\alpha\beta\gamma}\) is a 3D rotation parametrized by the angles \(\alpha, \beta\) and \(\gamma\); \((\Delta_x, \Delta_y, \Delta_z)^\intercal\) is a vector representation of a translation in space; and \(p_i\) are points on the bone surface from the preoperative CT scan. The function \(u\) gives the “gray values” at various points on the ultrasound, where larger values indicate bright areas (bone) and smaller values indicate darker areas (tissue). The above objective function searches for rigid transformation parameters so that the bone surface from the preoperative CT scan best matches the bone from the ultrasound. Figure 6 from the paper shows an ideal registration of an ultrasound.</p> <div class="row justify-content-sm-center"> <div class="col-sm-7 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/surface-480.webp 480w,/assets/img/cmaes/surface-800.webp 800w,/assets/img/cmaes/surface-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/surface.png" class="img-fluid rounded" width="100%" height="auto" title="surface" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 6: Example of (a) an intraoperative ultrasound, (b) its registered position, and (c) the corresponding CT image. The ultrasound is very noisy compared to the CT image. An ideal registration of the ultrasound image should align the bone (bright areas) with the highlighted bone surface from the CT. </div> <p>Since no additional structure is assumed in \(u\), CMA-ES is a good candidate for this problem, with suitable adjustments to make it a maximization algorithm.</p> <p>The authors simulate randomly perturbed ultrasound images, run CMA-ES along with other methods on these images, and assess the performance of the resulting transformation parameters. The competing methods are gradient-based, where the gradient is estimated numerically. Figure 7 from their paper shows the results.</p> <div class="row justify-content-sm-center"> <div class="col-sm-8 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/registration-480.webp 480w,/assets/img/cmaes/registration-800.webp 800w,/assets/img/cmaes/registration-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/registration.png" class="img-fluid rounded" width="100%" height="auto" title="registration" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 7: Misalignment of registration of various optimization methods. This plot shows that in about 80% of cases, CMA-ES resulted in misalignment by less than 0.01mm, outperforming other gradient-based methods. </div> <p>We see that CMA-ES outperforms the other methods by having a smaller degree of misalignment in a higher number of trials.</p> <h2 id="appendix">Appendix</h2> <h3 id="a1-choice-of-tuning-parameters">A.1 Choice of tuning parameters<a name="tuning"></a> </h3> <p>Throughout Section [<a href="#cma">3</a>], we introduced various tuning parameters that affect the covariance matrix and step size update. In this section, we provide the recommended settings for these parameters. These settings are discussed in [<a href="#ref1">1</a>]. Recall that the variance effective selection mass is given by</p> \[\mu_{\text{eff}} = \frac{1}{\sum_{i=1}^{m_{\text{elite}}} w_i^2}.\] <table> <thead> <tr> <th style="text-align: left">Parameter</th> <th style="text-align: left">Description</th> <th style="text-align: right">Value</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">\(c_c\)</td> <td style="text-align: left">Smoothing parameter for rank-one covariance update</td> <td style="text-align: right">\(\frac{4 + \mu_{\text{eff}}/n}{n + 4 + 2\mu_{\text{eff}}/n}\)</td> </tr> <tr> <td style="text-align: left">\(c_1\)</td> <td style="text-align: left">Learning rate for rank-one covariance update</td> <td style="text-align: right">\(\frac{2}{(n + 1.3)^2 + \mu_{\text{eff}}}\)</td> </tr> <tr> <td style="text-align: left">\(c_\mu\)</td> <td style="text-align: left">Learning rate for rank-\(\mu\) covariance update</td> <td style="text-align: right">\(\min\left(1-c_1, 2\frac{\mu_{\text{eff}}-2+1/\mu_{\text{eff}}} {(n+2)^2 + \mu_{\text{eff}}}\right)\)</td> </tr> <tr> <td style="text-align: left">\(c_\sigma\)</td> <td style="text-align: left">Smoothing parameter for step size update</td> <td style="text-align: right">\(\frac{\mu_{\text{eff}}+ 2}{n+\mu_{\text{eff}}+5}\)</td> </tr> <tr> <td style="text-align: left">\(d_\sigma\)</td> <td style="text-align: left">Step size adaptation parameter</td> <td style="text-align: right">\(1+ 2\left(0, \sqrt{(\mu_{\text{eff}} - 1)/(n+1)}-1\right)_+ + c_\sigma\)</td> </tr> </tbody> </table> <p><br></p> <h3 id="a2-test-functions">A.2 Test functions<a name="testfns"></a> </h3> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/flowerfn-480.webp 480w,/assets/img/cmaes/flowerfn-800.webp 800w,/assets/img/cmaes/flowerfn-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/flowerfn.png" class="img-fluid rounded" width="100%" height="auto" title="flower function" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/cmaes/michalfn-480.webp 480w,/assets/img/cmaes/michalfn-800.webp 800w,/assets/img/cmaes/michalfn-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/cmaes/michalfn.png" class="img-fluid rounded" width="100%" height="auto" title="Michalewicz function" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> <i>Left</i>: The flower function. <i>Right</i>: The 2D Michalewicz function. In this report we use the 20-dimensional version. </div> <h4 id="the-flower-function">The flower function</h4> <p>The flower function is the function \(f\colon \R^2 \to \R\) given by</p> \[f(\vec x) = a \lVert{\vec x}\rVert + b \sin (c \tan^{-1}(x_2, x_1)).\] <p>We use the typical settings of \(a = 1\), \(b = 1\), and \(c = 4\). The function is minimized near origin, although it is undefined at that point.</p> <h4 id="the-michalewicz-function">The Michalewicz function</h4> <p>The \(d\)-dimensional Michalewicz function \(f\colon \mathbb{R}^d \to \mathbb{R}\) is given by</p> \[f(\vec x) = - \sum_{i=1}^d \sin(x_i)\sin^{2m}\left(\frac{i x_i^2}{\pi}\right).\] <p>It has \(d!\) local minima. Global minima of \(f\) for \(d\) up to 75 are given in [<a href="#ref2">2</a>].</p> <h3 id="a3-the-cma-es-algorithm">A.3 The CMA-ES algorithm<a name="cmaesalg"></a> </h3> <hr> <p><strong>Algorithm 2:</strong> The Covariance Matrix Adaptation Evolutionary Strategy <br> <strong>Require:</strong> \(f\colon \R^n \to \R\), initial parameters \((\vec \mu^{(0)}, \vec\Sigma^{(0)}, \sigma^{(0)})\), \(m\) size of sample, \(m_{\text{elite}}\) size of elite subsample. <br> <strong>Ensure:</strong> \(\vec \mu^{(T)}\) is the mean of the final distribution and the proposed minimizer.</p> <p>For \(t = 0, 1, \dotsc\) until convergence:</p> <ul> <li>Sample points \(\vec x_1, \dotsc, \vec x_m\) from distribution \(N(\vec\mu^{(t)}, \sigma^{(t)}\vec \Sigma^{(t)})\).</li> <li>Set \(\vec\mu^{(t+1)}\) according to (\ref{eq:meanstep})</li> <li>Set \(\vec\Sigma^{(t+1)}\) according to (\ref{eq:covupdate})</li> <li>Set \(\sigma^{(t+1)}\) according to (\ref{eq:stepupdate})</li> </ul> <hr> <h2 id="references">References</h2> <p>[1]<a name="ref1"></a> Nikolaus Hansen. “The CMA Evolution Strategy: A Tutorial”. In: CoRR abs/1604.00772 (2016). arXiv: 1604.00772. url: <a href="http://arxiv.org/abs/1604.00772" rel="external nofollow noopener" target="_blank">http://arxiv.org/abs/1604.00772</a></p> <p>[2]<a name="ref2"></a> Charlie Vanaret et al. “Certified Global Minima for a Benchmark of Difficult Optimization Problems”. In: ArXiv abs/2003.09867 (2020)</p> <p>[3]<a name="ref3"></a> S Winter et al. “Registration of CT and Intraoperative 3-D Ultrasound Images of the Spine Using Evolutionary and Gradient-Based Methods”. eng. In: IEEE transactions on evolutionary computation 12.3 (2008), pp. 284–296. issn: 1089-778X.</p> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> Email: r_liu<span style="color:red">@</span>ucsb<span style="color:red">•</span>edu </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> </body> </html>